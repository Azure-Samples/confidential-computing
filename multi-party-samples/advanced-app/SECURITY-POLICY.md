# Confidential Computing Enforcement Policy (ccePolicy)

**Author:** Simon Gallagher, Senior Technical Program Manager, Azure Compute Security  
**Last Updated:** February 2026

> **Note:** See [ATTESTATION.md](ATTESTATION.md) for the full attestation flow and [README.md](README.md) for the main project documentation.

## Overview

The **Confidential Computing Enforcement Policy** (ccePolicy) is the cryptographic contract that defines **exactly what is allowed to run** inside an AMD SEV-SNP Trusted Execution Environment (TEE) on Azure Container Instances. It is written in [Rego](https://www.openpolicyagent.org/docs/latest/policy-language/) (Open Policy Agent's policy language), base64-encoded, and embedded in the ARM deployment template.

The SHA256 hash of this policy is placed into the `x-ms-sevsnpvm-hostdata` attestation claim by the AMD hardware. Azure Key Vault compares this hash against the key's release policy during Secure Key Release — **if any part of the policy changes, the hash changes, and keys will not be released**.

## Policy Generation

The policy is generated by the `az confcom` CLI extension:

```powershell
az confcom acipolicygen -a deployment-template.json --parameters deployment-params.json --disable-stdio --approve-wildcards
```

This command:
1. Pulls the container image locally
2. Inspects every Docker layer and computes SHA256 hashes
3. Analyses the entrypoint, environment variables, capabilities, and mounts
4. Generates a Rego policy that pins all of these values
5. Base64-encodes the policy and injects it into the ARM template's `ccePolicy` field
6. Outputs the policy hash (64-character hex string) to stdout

## Example Policy (Annotated)

Below is a real decoded ccePolicy from a Woodgrove Bank deployment. Sensitive values (Key Vault names, DNS labels, registry names) have been partially redacted.

> **Note:** Throughout this document, `***` denotes redacted portions of values from an example deployment. Your policy will have different hashes, endpoints, and container image references.

```rego
package policy

import future.keywords.every
import future.keywords.in

api_version := "0.10.0"
framework_version := "0.2.3"
```

### Section 1: Trusted Infrastructure Fragments

```rego
fragments := [
  {
    "feed": "mcr.microsoft.com/aci/aci-cc-infra-fragment",
    "includes": [
      "containers",
      "fragments"
    ],
    "issuer": "did:x509:0:sha256:I__iuL25oXEVFdTP_aBLx_eT1RPHbCQ_ECBQfYZpt9s::eku:1.3.6.1.4.1.311.76.59.1.3",
    "minimum_svn": "1"
  }
]
```

**What this does:**
- Trusts Microsoft's ACI infrastructure fragment — a signed policy package from Microsoft's container registry
- The `issuer` is a DID (Decentralized Identifier) tied to a specific Microsoft x509 certificate
- `minimum_svn` (Security Version Number) of `"1"` ensures the fragment hasn't been rolled back to a vulnerable version
- This fragment provides the base ACI platform behavior that the rest of the policy delegates to

### Section 2: Authorised Containers

This is the core of the policy. Every container that can run inside the TEE must be explicitly listed with its exact image, layer hashes, command, environment variables, capabilities, and mounts.

#### Container 1: Application Container (`attestation-demo`)

```rego
containers := [
  {
    "name": "attestation-demo",
    "id": "acr***ugez.azurecr.io/aci-attestation-demo:latest",
```

**Image & Layer Pinning** — every Docker layer is pinned by SHA256 hash. If a single byte changes in any layer, attestation fails:

```rego
    "layers": [
      "48f93672ab54ba2391***877b8bdadca1fdba2e0a08c62e9b839e668c33d",
      "3b9c603071bb6e39aab7ebbd6657c8885fe3dbb1cb74c4e85e6556f66e7fbe4d",
      "7bdc384028e58eae52c334bca7a14e9494e37700c04a2ee70ae3f1c52689e35f",
      "90e776c4d2cefb215cae38cd0b11356adc0bf10ec7ca72b09de5080e706db38f",
      "454066c7aa96ff63138db955834fbabe***7f788c9b1e3383081b8b98b299668",
      "29a7a736fe4fc958ae8437f7a1f6e1ddae3337fb6ae71393ed3aa3105073637b",
      "defec53fa60948b10e42faab22ddb60b102e0e160363ff9d1fdcb5b8f2ef627a",
      "1c1ccf8791a4e107db6827e3e1a6fe333cccaa4ca289a81c3889bb3f3afde8f1",
      "e803c460b31a41f44a6bec9dfcc6a5502e3317313020c23ac88ee2e9eef2ac34",
      "6664542faa2a89c92187a3af11194765e45effaf1a4bba821b310c539c2c441b",
      "3902673303d296***9189fa012de80326f7662e9b75a0a5367211c98964a4f1",
      "b2722b95a92a4df49bddb03eeaee307a4a632c3351a91084a52a654b4131b75e",
      "6f562edc01bd733c21f50c929572d80ccb3d51bede29676e2bdb34c9e36f397c",
      "10fd4a7c61613ac943060a3492666d237994e6a630b3dbbe2ea6a825d3c2802f",
      "c527af5953ffa99b5ffc625211a8e414a1d4a074e276ae447e15a0d5a5e95e95",
      "c5aef5c6f39bcea08f10a04e3b906db337269***e8db0807bc76a6bd77f81fa6",
      "540da50945929f2593b653d790f18723ae27603853957bd6e6c594c8cea6489c",
      "964d91e8b50d07d46fbc726d85a2d5fb4925e43fcd14ea0a5f9449c25e598641"
    ],
```

**Entrypoint** — only this exact command is allowed. It cannot be overridden at deployment time:

```rego
    "command": ["/usr/bin/supervisord", "-c", "/etc/supervisor/conf.d/supervisord.conf"],
    "working_dir": "/app",
```

**Security Flags:**

```rego
    "allow_elevated": false,       // No privilege escalation
    "allow_stdio_access": false,   // No stdin/stdout from host (blocks az container exec)
    "no_new_privileges": false,    // Standard Linux default
    "exec_processes": [],          // No docker exec — nobody can shell in
```

**Linux Capabilities** — standard container capabilities, no dangerous ones like `CAP_SYS_ADMIN`:

```rego
    "capabilities": {
      "bounding":   ["CAP_AUDIT_WRITE", "CAP_CHOWN", "CAP_DAC_OVERRIDE", "CAP_FOWNER",
                     "CAP_FSETID", "CAP_KILL", "CAP_MKNOD", "CAP_NET_BIND_SERVICE",
                     "CAP_NET_RAW", "CAP_SETFCAP", "CAP_SETGID", "CAP_SETPCAP",
                     "CAP_SETUID", "CAP_SYS_CHROOT"],
      "effective":  ["(same list)"],
      "permitted":  ["(same list)"],
      "inheritable": [],
      "ambient":     []
    },
```

| Capability | Why Needed |
|---|---|
| `CAP_NET_BIND_SERVICE` | Bind to ports below 1024 (nginx on 80/443) |
| `CAP_CHOWN`, `CAP_DAC_OVERRIDE`, `CAP_FOWNER` | File permission management |
| `CAP_SETUID`, `CAP_SETGID` | Supervisor managing child processes |
| `CAP_NET_RAW` | Raw network access |
| `CAP_SYS_CHROOT` | Container filesystem isolation |

**Environment Variable Rules** — every environment variable is explicitly controlled:

```rego
    "env_rules": [
      // === Application-specific (exact string match) ===
      {"pattern": "SKR_KEY_NAME=woodgrove-secret-key",                                     "strategy": "string"},
      {"pattern": "SKR_MAA_ENDPOINT=sharedeus.eus.attest.azure.net",                       "strategy": "string"},
      {"pattern": "SKR_AKV_ENDPOINT=kv***ugezc.vault.azure.net",                           "strategy": "string"},
      {"pattern": "RESOURCE_GROUP_NAME=sgall***ugez-rg",                                   "strategy": "string"},
      {"pattern": "PARTNER_CONTOSO_AKV_ENDPOINT=kv***ugeza.vault.azure.net",               "strategy": "string"},
      {"pattern": "PARTNER_FABRIKAM_AKV_ENDPOINT=kv***ugezb.vault.azure.net",              "strategy": "string"},
      {"pattern": "PARTNER_CONTOSO_URL=https://contoso-***1933.eastus.azurecontainer.io",   "strategy": "string"},
      {"pattern": "PARTNER_FABRIKAM_URL=https://fabrikam-***1933.eastus.azurecontainer.io", "strategy": "string"},
      {"pattern": "SECURITY_POLICY_HASH=",                                                 "strategy": "string"},

      // === Secrets (regex — value injected at runtime) ===
      {"pattern": "AZURE_STORAGE_CONNECTION_STRING=.*",   "strategy": "re2"},

      // === Python base image defaults ===
      {"pattern": "PATH=/usr/local/bin:/usr/local/sbin:...",        "strategy": "string"},
      {"pattern": "GPG_KEY=7169605F62C751356D***26A821E680E5FA6305", "strategy": "string"},
      {"pattern": "PYTHON_VERSION=3.13.12",                         "strategy": "string"},
      {"pattern": "PYTHON_SHA256=2a84cd31dd***6de66fc1b4b0127dd5799aa50a64ae9a313885b4593", "strategy": "string"},
      {"pattern": "TERM=xterm",                                     "strategy": "string"},

      // === ACI platform variables (regex — injected by host) ===
      {"pattern": "(?i)(FABRIC)_.+=.+",                "strategy": "re2"},
      {"pattern": "HOSTNAME=.+",                       "strategy": "re2"},
      {"pattern": "T(E)?MP=.+",                        "strategy": "re2"},
      {"pattern": "FabricPackageFileName=.+",          "strategy": "re2"},
      {"pattern": "HostedServiceName=.+",              "strategy": "re2"},
      {"pattern": "IDENTITY_API_VERSION=.+",           "strategy": "re2"},
      {"pattern": "IDENTITY_HEADER=.+",                "strategy": "re2"},
      {"pattern": "IDENTITY_SERVER_THUMBPRINT=.+",     "strategy": "re2"},
      {"pattern": "azurecontainerinstance_restarted_by=.+", "strategy": "re2"}
    ],
```

**Why this matters for security:**
- `SKR_AKV_ENDPOINT` is pinned to an exact Key Vault — changing it to steal keys from a different vault would change the policy hash
- `PARTNER_CONTOSO_URL` and `PARTNER_FABRIKAM_URL` are pinned — a malicious redirect to a fake container would change the hash
- `AZURE_STORAGE_CONNECTION_STRING` uses regex (`re2`) because it's a secret injected at deployment time
- ACI platform variables use regex because their values are dynamic per-host

**Mounts** — only the DNS resolver config is allowed:

```rego
    "mounts": [
      {
        "destination": "/etc/resolv.conf",
        "source": "sandbox:///tmp/atlas/resolvconf/.+",
        "type": "bind",
        "options": ["rbind", "rshared", "rw"]
      }
    ],
```

No other host filesystem mounts are permitted. An attacker cannot mount host directories to exfiltrate data.

#### Container 2: Pause Container (ACI Infrastructure)

```rego
  {
    "name": "pause-container",
    "command": ["/pause"],
    "layers": ["16b514057a06ad665f92c02863aca074fd5976c755d26bff16365299169e8415"],
    "env_rules": [
      {"pattern": "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", "required": true, "strategy": "string"},
      {"pattern": "TERM=xterm", "required": false, "strategy": "string"}
    ],
    "mounts": [],
    "exec_processes": [],
    "working_dir": "/"
  }
]
```

This is Azure's standard pause container — it holds the network namespace open. Single layer, pinned by hash, minimal environment, no mounts.

### Section 3: Global Security Flags

```rego
allow_properties_access := true
allow_dump_stacks := false
allow_runtime_logging := false
allow_environment_variable_dropping := true
allow_unencrypted_scratch := false
allow_capability_dropping := true
```

| Flag | Value | Security Implication |
|---|---|---|
| `allow_properties_access` | `true` | Container can read its own metadata |
| `allow_dump_stacks` | **`false`** | Prevents stack dumps that could leak memory contents |
| `allow_runtime_logging` | **`false`** | Prevents runtime debug logging that could leak secrets |
| `allow_environment_variable_dropping` | `true` | Can drop unneeded env vars (defense in depth) |
| `allow_unencrypted_scratch` | **`false`** | **Scratch storage must be encrypted** — temp files are protected |
| `allow_capability_dropping` | `true` | Can drop Linux capabilities (defense in depth) |

### Section 4: Framework Delegation

```rego
mount_device := data.framework.mount_device
unmount_device := data.framework.unmount_device
mount_overlay := data.framework.mount_overlay
unmount_overlay := data.framework.unmount_overlay
create_container := data.framework.create_container
exec_in_container := data.framework.exec_in_container
exec_external := data.framework.exec_external
shutdown_container := data.framework.shutdown_container
signal_container_process := data.framework.signal_container_process
plan9_mount := data.framework.plan9_mount
plan9_unmount := data.framework.plan9_unmount
get_properties := data.framework.get_properties
dump_stacks := data.framework.dump_stacks
runtime_logging := data.framework.runtime_logging
load_fragment := data.framework.load_fragment
scratch_mount := data.framework.scratch_mount
scratch_unmount := data.framework.scratch_unmount

reason := {"errors": data.framework.errors}
```

All runtime operations (mount, create, exec, shutdown, signal) are delegated to Microsoft's trusted infrastructure framework fragment (loaded in Section 1). The framework enforces all the container definitions and security flags defined above.

The `reason` line is the **policy violation reporting mechanism**. When the ACI runtime evaluates an operation against this policy and the operation is **denied**, the framework collects error messages explaining why. For example, if someone deployed a container with a modified image layer, the framework would find the layer hash doesn't match, and `reason` would surface as:

```json
{
  "errors": [
    "container image layer hash does not match policy"
  ]
}
```

This gets logged by the ACI runtime — it's how you diagnose why a confidential container failed to start, without leaking any sensitive data from inside the TEE.

## How This Policy Enables Multi-Party Trust

This policy is the **trust anchor** for the entire multi-party system:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Trust Chain                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. az confcom generates policy ──► Policy hash computed                 │
│                                          │                               │
│  2. Policy hash bound to Key Vault  ◄────┘                               │
│     key release policy                                                   │
│                                                                          │
│  3. Container starts in AMD SEV-SNP TEE                                  │
│     Hardware measures policy ──► hostdata = policy hash                  │
│                                          │                               │
│  4. SKR requests attestation from MAA    │                               │
│     MAA includes hostdata in JWT ◄───────┘                               │
│                                          │                               │
│  5. Key Vault verifies JWT claims        │                               │
│     hostdata == release policy hash? ◄───┘                               │
│          │                                                               │
│     YES: Release key ──► Decryption inside TEE                          │
│     NO:  Reject ──► Key stays locked                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### What Changing the Policy Breaks

| If an attacker modifies... | Effect |
|---|---|
| Container image (any layer) | Layer hashes change → policy hash changes → key not released |
| Entrypoint command | Command changes → policy hash changes → key not released |
| Environment variables | Env rules change → policy hash changes → key not released |
| `SKR_AKV_ENDPOINT` (redirect to different vault) | Env rule changes → policy hash changes → key not released |
| `PARTNER_CONTOSO_URL` (redirect to fake container) | Env rule changes → policy hash changes → key not released |
| Linux capabilities (add `CAP_SYS_ADMIN`) | Capabilities change → policy hash changes → key not released |
| Mount points (add host filesystem) | Mounts change → policy hash changes → key not released |
| `allow_stdio_access` (enable shell) | Security flag changes → policy hash changes → key not released |

This is why Contoso and Fabrikam can trust Woodgrove's container — even though Woodgrove controls the deployment, the policy is cryptographically measured by AMD hardware and verified by Azure Attestation before any keys are released.
